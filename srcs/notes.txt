
wp-config.php in wordpress root

<?php
/**
 * The base configuration for WordPress
 *
 * The wp-config.php creation script uses this file during the installation.
 * You don't have to use the website, you can copy this file to "wp-config.php"
 * and fill in the values.
 *
 * This file contains the following configurations:
 *
 * * Database settings
 * * Secret keys
 * * Database table prefix
 * * ABSPATH
 *
 * @link https://wordpress.org/documentation/article/editing-wp-config-php/
 *
 * @package WordPress
 */

// ** Database settings - You can get this info from your web host ** //
/** The name of the database for WordPress */
define( 'DB_NAME', '' );

/** Database username */
define( 'DB_USER', 'wordpress' );

/** Database password */
define( 'DB_PASSWORD', '123456' );

/** Database hostname */
define( 'DB_HOST', 'localhost' );

/** Database charset to use in creating database tables. */
define( 'DB_CHARSET', 'utf8' );

/** The database collate type. Don't change this if in doubt. */
define( 'DB_COLLATE', '' );

/**#@+
 * Authentication unique keys and salts.
 *
 * Change these to different unique phrases! You can generate these using
 * the {@link https://api.wordpress.org/secret-key/1.1/salt/ WordPress.org secret-key service}.
 *
 * You can change these at any point in time to invalidate all existing cookies.
 * This will force all users to have to log in again.
 *
 * @since 2.6.0
 */
define( 'AUTH_KEY',         'put your unique phrase here' );
define( 'SECURE_AUTH_KEY',  'put your unique phrase here' );
define( 'LOGGED_IN_KEY',    'put your unique phrase here' );
define( 'NONCE_KEY',        'put your unique phrase here' );
define( 'AUTH_SALT',        'put your unique phrase here' );
define( 'SECURE_AUTH_SALT', 'put your unique phrase here' );
define( 'LOGGED_IN_SALT',   'put your unique phrase here' );
define( 'NONCE_SALT',       'put your unique phrase here' );

/**#@-*/

/**
 * WordPress database table prefix.
 *
 * You can have multiple installations in one database if you give each
 * a unique prefix. Only numbers, letters, and underscores please!
 */
$table_prefix = 'wp_';

/**
 * For developers: WordPress debugging mode.
 *
 * Change this to true to enable the display of notices during development.
 * It is strongly recommended that plugin and theme developers use WP_DEBUG
 * in their development environments.
 *
 * For information on other constants that can be used for debugging,
 * visit the documentation.
 *
 * @link https://wordpress.org/documentation/article/debugging-in-wordpress/
 */
define( 'WP_DEBUG', false );

/* Add any custom values between this line and the "stop editing" line. */



/* That's all, stop editing! Happy publishing. */

/** Absolute path to the WordPress directory. */
if ( ! defined( 'ABSPATH' ) ) {
        define( 'ABSPATH', __DIR__ . '/' );
}

/** Sets up WordPress vars and included files. */
require_once ABSPATH . 'wp-settings.php';






// Simply put, a container is simply another process on your machine that has been isolated 
// from all other processes on the host machine. 

// When running a container, it uses an isolated filesystem. 
//This custom filesystem is provided by a container image. 
//Since the image contains the container's filesystem, it must contain 
//everything needed to run an application - all dependencies, configuration, scripts, binaries, etc. 

// Dockerfiles are used to build applications (inside containers?)

// A Dockerfile is simply a text-based script of instructions that is used to create a container image

// you can start a container from an image ? (What does that exactly mean?)

// build a container image from Dockerfile --> docker build
// create a container from an image --> docker create <image_name>
// creates and runs a container based on the given image --> docker run <image_name>

// Docker images are read-only templates that contain instructions for creating a container. 
// A Docker image is a snapshot or blueprint of the libraries and dependencies required inside a container 
// for an application to run.

// A Docker container is a runtime environment with all the necessary components—like code, 
// dependencies, and libraries—needed to run the application code without using host machine dependencies.
// This container runtime runs on the engine on a server, machine, or cloud instance. The engine runs 
// multiple containers depending on the underlying resources available.
// Running instance of an image

// A Docker image, or container image, is a standalone, executable file used to create a container. 
// This container image contains all the libraries, dependencies, and files that the container needs 
// to run. A Docker image is shareable and portable, so you can deploy the same image in multiple 
// locations at once—much like a software binary file. It is the template loaded onto the 
// container to run it, like a set of instructions.
// You store images for sharing and reuse, but you create and destroy containers over an application’s lifecycle. 

// docker ps -a --> list all containers
// docker start <container_id> --> runs a container
// docker stop <container_id> --> stops a container

//  only one process (containers included) can listen to a specific port

// This is quite common in CI pipelines, where the pipeline will create the image and push it to a registry and then 
// the production environment can use the latest version of the image.

// Volumes can be used to make data persistent. They provide the ability to connect specific 
// filesystem paths of the container back to the host machine. 
// If a directory in the container is mounted, changes in that directory are also seen on the host machine. 
// If we mount that same directory across container restarts, we'd see the same files.


// mounting:: creating a volume and attaching (often called "mounting") it to the directory the data is stored in

// create a volume (in this case todo-db) -> docker volume create todo-db
// then start the container with the -v flag

// use bind mounts to control exact mountpoints on the host when using volumes
// this can also be used to mount source code into a container for development etc.
// For Node-based applications, nodemon is a great tool to watch for file changes and then restart the application. 
// There are equivalent tools in most other languages and frameworks.

// With Docker Compose, we can share our application stacks in a much easier way and let others spin them up 
// with a single (and simple) command!
// developed to help define and share multi-container applications. With Compose, we can create a YAML file to
// define the services and with a single command, can spin everything up or tear it all down. 


// By default, Docker Compose automatically creates a network specifically for the application stack
